## 第一章
1. 冯·诺伊曼结构 p10
- 将解题的程序(指令序列)存放到存储器中称为存储程序
- 存储程序按地址顺序执行
2.  两种字长
- 处理器字长 p5 ：指处理机运算器中一次能够完成二进制数**运算**的位数
- 机器字长 p122 ：机器字长是指计算机能**直接处理**的二进制数据的位数，它决定了计算机的运算精度
3. 计算机系统的层次结构
![[Pasted image 20240125132006.png]]
- 汇编语言 p15 ——特定于硬件，最靠近机器的
## 第二章
1. 定点数在机器中用补码表示 p17 
2. 加减法——注意溢出
- 双符号位（变形补码） p30 ：（1）任何正数，两个符号位都是“0”，任何负数， 两个符号位都是“1” （2）其结果的符号位出现“01” 或“10”两种组合时，表示发生溢出。最高符号位永远表示结果的正确符号，即01为正溢出，10为负溢出 
- P.S. mod 2<sup>n+2</sup>指去掉符号位最高位的进位，只留下n位原数据和2位符号位
- ***单符号位法*** p30 ：正数相加变成负数，或是负数相加成为正数
- 两个正数相加，结果大于机器字长所能表示的最大正数，称为*正溢*。而两个负数相加，结果小于机器所能表示的最小负数，称为*负溢*
![[Pasted image 20240125133708.png]]
3. 除法 p38 ：
- 手算方法：每步需右移除数，够减则商1做减法，不够减则保持余数
- ***加减交替法*** p42 ：
![[Pasted image 20240125134321.png]]
4. n位机器码可表示数的范围有多大 p24 ：
- n位全1值为2<sup>n</sup>-1
- 分为正负两种情况讨论
![[Pasted image 20240125134900.png]]
6. <sub>（5的缺少是神的警告，要细心）</sub>浮点运算方法 p51 ：
- ***运算步骤***
	1. 0 操作数检查：两个操作数 x 或 y 中有一个数为0则直接输出结果
	2. **比较阶码大小并完成对阶**：小阶向大阶对齐（如-120向-100）
	3. **尾数加减运算**
	4. **结果规格化**：尾数移动，阶码相应变化，左减右加，直到为1.M形式
	5. 舍入处理：
	- 就近舍入：>10000进1，<10000舍去，=10000则若最低有效位现为 0，则截尾；若最低有效位现为 1，则向上进 1 位使其变为 0
	- 朝0舍入：截尾
	- 朝+∞舍入：对正数来说，只要多余位不全为 0 则向最低有效位进 1；对负数来说，则 是简单的截尾
	- 朝–∞舍入：对正数来说，则是简单截尾；对负数来说，只要多余位不全为 0，则向最低有效位进 1
	6. 溢出处理：
	- 阶码上溢：超过了阶码可能表示的最大值的正指数值，一般将其认为是+∞和–∞
	- 阶码下溢：超过了阶码可能表示的最小值的负指数值，一般将其认为是 0
	- 尾数上溢：两个同符号尾数相加产生了最高位向上的进位，要将尾数右移，阶码增 1 来重新对齐
	- 尾数下溢：在将尾数右移时，尾数的最低有效位超出尾数域右端，要进行舍入处理
	![[Pasted image 20240125151408.png]]
7. 流水线浮点加法器 p58 ：（算术流水线 p178 ）
![[Pasted image 20240125152327.png]]
- 4个阶段：
	1. 0 操作数检查（图中省略）
	2. 对阶
	3. 相加
	4. 规格化
8. 计算部分：
- 十进制与浮点数转换：8位阶码，23位尾数（4\*5+3）
![[9ca5965e1561ad85349334cf713e507.jpg]]
![[3dcc59a20e937400200731d1c3daea7.jpg]]
- 浮点数加减法
![[c8f705f13c79910b2819f14736ca3a3.jpg]]
![[Pasted image 20240125155528.png]]
## 第四章
1. 机器指令 p118 ：
- 微指令是微程序级的命令，它属于硬件
- 宏指令是由若干条机器指令组成的软件指令，它属于软件
- 机器指令则介于微指令与宏指令之间， 通常简称为指令，每一条指令可完成一个独立的算术运算或逻辑运算操作
- 本章所讨论的指令，是机器指令
2. 机器字长（见第一章）：
- 指令字长度等于机器字长度->单字长指令
- 指令字长度等于半个机器字长度->半字长指令
- 指令字长度等于两个机器字长度->为双字长指令
3. 扩展操作码 p123 ：
- 设某等长指令字结构机器的指令长度为 16 位，包括 4 位基本操作码字段和三个 4 位地址字段
![[Pasted image 20240125213348.png]]
- 即OP域（三地址指令：留出三个地址空间的指令）留出1111用于把操作码扩展到 A<sub>1</sub> 地址域；二地址指令留出1110和1111；一地址域留出1111
4. 寻址方式 p130 ：
	1. 隐含寻址：操作数在专用寄存器，不是明显地给出操作数的地址
	2. 立即寻址：D=A，地址字段指出操作数本身（立即数）
	3. 直接寻址：D=(A)，EA=A，地址字段中直接指出操作数在内存的地址（直接地址）
	4. 间接寻址：EA=(A)，地址字段中指出操作数地址的指示器
	 ![[Pasted image 20240125215052.png]]
	6. 寄存器寻址：EA=R，*RR 型指令*，指令中给出的操作数地址是通用寄存器的编号
	7. 寄存器间接寻址：EA=(R)，指令格式中的寄存器内容是操作数的地址
	8. 偏移寻址：EA=A+(R)，形式地址A直接被使用，另一个地址字段，或基于操作码的一个隐含引用，指的是某个专用寄存器
	9. 相对寻址：EA=A+(PC)程序计数器
	10. 基址寻址：EA=(B)+(R)（书上没写），引用的专用寄存器含有一个存储器地址（可隐可现），地址字段含有一个相对于该地址的偏移量
	11. 变址寻址：EA=A+(R)，R←(R+1)
	![[Pasted image 20240125220205.png]]
## 第五章
1. 指令周期 p148 ：
- 指令周期是取出一条指令并执行这条指令的时间
- 由于各种指令的操作功能不同，因此各种指令的指令周期是**不尽相同**的
- CPU 周期又称为机器周期，指令周期常常用若干个 CPU 周期数来表示
- 一个 CPU 周期时间又包含有若干个时钟周期（访问一次寄存器所需时间）(又称 T 周期或节拍脉冲，它是处理操作的最基本单位) 
![[697d4af0b879720193ac112d7f81dfb.jpg]]
2. MOV（*RR 型指令*）取指周期和执行指令阶段(执行周期) p150 ：
![[Pasted image 20240125224134.png]]
- 取指周期：
	1.  程序计数器 PC 中装入第一条指令地址 101(八进制)
	2. PC 的内容被放到指令地址总线 ABUS(I)上，对指存进行译码，并启动读命令
	3. 从 101 号地址读出的 MOV 指令通过指令总线 IBUS 装入指令寄存器 IR
	4. 程序计数器内容加 1，变成 102，为取下一条指令做好准备
	5. 指令寄存器中的操作码(OP)被译码
	6. CPU 识别出是 MOV 指令。
	![[Pasted image 20240125222746.png]]
- 执行周期：
	1. 操作控制器(OC)送出控制信号到通用寄存器，选择 R1(10)作源寄存器，选择 R0 作目标寄存器
	2. OC 送出控制信号到 ALU，指定 ALU 做传送操作
	3. OC 送出控制信号，打开 ALU 输出三态门，将 ALU 输出送到数据总线 DBUS 上。 注意，任何时候 DBUS 上只能有一个数据
	4. OC 送出控制信号，将 DBUS 上的数据打入到数据缓冲寄存器 DR(10)
	5. OC 送出控制信号，将 DR 中的数据 10 打入到目标寄存器 R0，R0 的内容由 00 变为 10
	![[Pasted image 20240125222847.png]]
	