## 第一章
1. 冯·诺伊曼结构 p10
- 将解题的程序(指令序列)存放到存储器中称为存储程序
- 存储程序按地址顺序执行
2.  两种字长
- 处理器字长 p5 ：指处理机运算器中一次能够完成二进制数**运算**的位数
- 机器字长 p122 ：机器字长是指计算机能**直接处理**的二进制数据的位数，它决定了计算机的运算精度
3. 计算机系统的层次结构
![[Pasted image 20240125132006.png]]
- 汇编语言 p15 ——特定于硬件，最靠近机器的
## 第二章
1. 定点数在机器中用补码表示 p17 
2. 加减法——注意溢出
- 双符号位（变形补码） p30 ：（1）任何正数，两个符号位都是“0”，任何负数， 两个符号位都是“1” （2）其结果的符号位出现“01” 或“10”两种组合时，表示发生溢出。最高符号位永远表示结果的正确符号，即01为正溢出，10为负溢出 
- P.S. mod 2<sup>n+2</sup>指去掉符号位最高位的进位，只留下n位原数据和2位符号位
- ***单符号位法*** p30 ：正数相加变成负数，或是负数相加成为正数
- 两个正数相加，结果大于机器字长所能表示的最大正数，称为*正溢*。而两个负数相加，结果小于机器所能表示的最小负数，称为*负溢*
![[Pasted image 20240125133708.png]]
3. 除法 p38 ：
- 手算方法：每步需右移除数，够减则商1做减法，不够减则保持余数
- ***加减交替法*** p42 ：
![[Pasted image 20240125134321.png]]
4. n位机器码可表示数的范围有多大 p24 ：
- n位全1值为2<sup>n</sup>-1
- 分为正负两种情况讨论
![[Pasted image 20240125134900.png]]
6. <sub>（5的缺少是神的警告，要细心）</sub>浮点运算方法 p51 ：
- ***运算步骤***
	1. 0 操作数检查：两个操作数 x 或 y 中有一个数为0则直接输出结果
	2. **比较阶码大小并完成对阶**：小阶向大阶对齐（如-120向-100）
	3. **尾数加减运算**
	4. **结果规格化**：尾数移动，阶码相应变化，左减右加，直到为1.M形式
	5. 舍入处理：
	- 就近舍入：>10000进1，<10000舍去，=10000则若最低有效位现为 0，则截尾；若最低有效位现为 1，则向上进 1 位使其变为 0
	- 朝0舍入：截尾
	- 朝+∞舍入：对正数来说，只要多余位不全为 0 则向最低有效位进 1；对负数来说，则 是简单的截尾
	- 朝–∞舍入：对正数来说，则是简单截尾；对负数来说，只要多余位不全为 0，则向最低有效位进 1
	6. 溢出处理：
	- 阶码上溢：超过了阶码可能表示的最大值的正指数值，一般将其认为是+∞和–∞
	- 阶码下溢：超过了阶码可能表示的最小值的负指数值，一般将其认为是 0
	- 尾数上溢：两个同符号尾数相加产生了最高位向上的进位，要将尾数右移，阶码增 1 来重新对齐
	- 尾数下溢：在将尾数右移时，尾数的最低有效位超出尾数域右端，要进行舍入处理
	![[Pasted image 20240125151408.png]]
7. 流水线浮点加法器 p58 ：（算术流水线 p178 ）
![[Pasted image 20240125152327.png]]
- 4个阶段：
	1. 0 操作数检查（图中省略）
	2. 对阶
	3. 相加
	4. 规格化
8. 计算部分：
- 十进制与浮点数转换：8位阶码，23位尾数（4\*5+3）
![[9ca5965e1561ad85349334cf713e507.jpg]]
![[3dcc59a20e937400200731d1c3daea7.jpg]]
- 浮点数加减法
![[c8f705f13c79910b2819f14736ca3a3.jpg]]
![[Pasted image 20240125155528.png]]
## 第四章
1. 机器指令 p118 ：
- 微指令是微程序级的命令，它属于硬件
- 宏指令是由若干条机器指令组成的软件指令，它属于软件
- 机器指令则介于微指令与宏指令之间， 通常简称为指令，每一条指令可完成一个独立的算术运算或逻辑运算操作
- 本章所讨论的指令，是机器指令
2. 机器字长（见第一章）：
- 指令字长度等于机器字长度->单字长指令
- 指令字长度等于半个机器字长度->半字长指令
- 指令字长度等于两个机器字长度->为双字长指令
3. 扩展操作码