# 第三章
## 储存器扩展 p68-69
1. 【69 3.7】字扩展：利用多片1M×4位的SRAM芯片设计一个存储容量为1M×8位的SRAM存储器。
![[Pasted image 20240516152142.png]]
2. 【69 3.8】位扩展：利用256K×8位的SRAM芯片设计2048K×8位的存储器。
![[Pasted image 20240516152302.png]]
3. 字位扩展：
![[eb9c596c10aec37ece2f75832b5bec2.jpg]]
4. *数据线、地址线、存储芯片和CPU怎么连接、片选信号+经过译码器后和储存芯片连接*

## 储存器的硬件指标 p65
1. 存储容量：其中1KB=$2^{10}$B，1MB=$2^{20}$B，1GB=$2^{30}$B， 1TB=$2^{40}$B。为了清楚地表示其组织结构，存储容量也可表示为：存储字数(存储单元数)× 存储字长(每单元的比特数)。例如，1Mbit 容量的存储器可以组织成 1M×1bit，也可组织成 128K×8bit，或者 512K×4bit。
2. 存取时间：又称存储器访问时间，是从存储器接收到读/写命令开始到信息被读出或写入完成所需的时间。
3. 存储周期(存取周期)：是在存储器连续读写过程中一次完整的存取操作所需的时间， 即CPU连续两次访问存储器的最小间隔时间。通常，存储周期略大于存取时间。
4. 【90 3.3】设存储器容量为32字，字长64位，模块数m=4，分别用顺序方式和交叉方式进行组织。存储周期T=200ns，数据总线宽度为64位，总线传送周期τ=50ns。若连续 读出4个字，问顺序存储器和交叉存储器的带宽各是多少?
![[Pasted image 20240516154659.png]]
## cache的评价指标 p93
1. **命中率**：$\frac{cache完成存取的总次数}{cache完成存取的总次数+主存完成存取的总次数}$
![[Pasted image 20240516155230.png]]
3. **cache/主存系统的平均访问时间**：
$cache访问时间\times 命中率+(1-命中率)\times 主存访问时间$
![[Pasted image 20240516155534.png]]
4. **访问效率**：$\frac{1}{命中率+(1-命中率)\times 主存与cache的访问时间之比}$ 
![[Pasted image 20240516155849.png]]
5. 为提高访问效率，命中率h越接近1越好。r值以5～10为宜，不宜太大。
6. 【93 3.4】CPU执行一段程序时，cache完成存取的次数为1900次，主存完成存取的次数为100次，已知cache存取周期为50ns，主存存取周期为250ns，求cache/主存系统的效率和平均访问时间。
7. *几个概念的定义以及计算方式*
## 地址映射的三种方式 p94
1. *全相连映射的组织方式、映射地址所带来的地址结构、组织方式不一样导致储存地址的组成部分不一样，位数也不同、全相连是需要比对的位数和块号是一一对应的、检索过程，图上的字段编号，比较的东西是什么*
2. 全相连：将主存中一个块的地址(块号)与块的内容(字)一起存于cache的行中，其中块地址存于cache行的标记(tag)部分中。【3.30】*地址字段的位长度为什么一个是s一个是w，比较器为什么要比较s个二进制位：因为是全相连映射，需要比较所有的块才能确定储存的块是我需要的块*
![[Pasted image 20240517162952.png]]

3. 直接映射方式：一个主存块只能拷贝到cache的一个特定 行位置上去。将s位的主存块地址分成两部分：低r位主存区内块号作为cache 的行地址，s–r位区号作为标记(tag)与块数据一起保存在该行。当CPU以一个给定的内存 地址访问cache时，首先用r位区内块号找到cache中的特定一行，然后用地址中的s–r位 区号部分与此行的标记在比较器中做比较。*直接映射的比较过程：只需要比较区号，因为区内块号是直接映射*
![[Pasted image 20240517164004.png]]
4. 组相联映射方式：内存地址中，s位块号划分成两部分：低d位(2d=u)主存区内块号用于表示cache组号(而 不是cache行号)，高s–d位区号作为标记与块数据一起存于此组的某行中。*地址组成的位数和组相连的是不一样的*
![[Pasted image 20240517164454.png]]
![[Pasted image 20240517165253.png]]
## cache的替换策略 p100
1. 最不经常使用算法-LFU：*将一段时间内被访问次数最少的那行数据换出。*
   新行调入后从0开始计数，每访问一次，被访行的计数器增1。当需要替换时，对 这些特定行的计数值进行比较，将计数值最小的行换出，同时将这些特定行的计数器都清零。
2. 近期最少使用算法-LRU：*将近期内长久未被访问过的行换出。*
   cache每命中一次，命中行计数器清零，其他各行计数器增1。当需要替换时，比较各特 定行的计数值，将计数值最大的行换出。
3. 随机替换
## 虚拟存储器
1. *cache和虚存的异同* p104-105 