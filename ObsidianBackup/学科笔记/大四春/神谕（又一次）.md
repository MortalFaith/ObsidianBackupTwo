>按章节和知识点分类，梳理下神提到的明确的、有书上页码的部分
>2014版请将每个页数-4或-5
>感谢成老师和大陆老师提供的支持

>题型为：判断、选择、填空简答和综合题
>综合题范围：存储管理系统中的分页管理中的替换算法，文件系统当中对磁盘的组织方式（如何组织文件），磁盘的磁道算法
>
>食用方法：==**高亮部分**==是神谕相互重叠，所有**粗体**的部分都是神明确说明要掌握的，正常字体是书上的对前面概念的介绍或是神的解释
>~~我的理解是把所有粗体的部分结合冒号后面的解释先理解一遍，重点关照疑似大题的部分，要到能自己组织语言解释粗体的程度，剩下的粗体和补充部分能理解/背多少就看自己造化了，毕竟背做大题的知识点肯定比背做小题的知识点赚（）~~
>普罗米修斯本普
>
>以下这段文字仅仅是以一种文体去描写复习操作系统的过程，仅仅出于语文赏析的需要，不带有任何宗教立场：
>那时，LFF站在讲台前，如同橄榄山上点灯的守望者。她开口说："要记念进程如麦粒，不可任其饥饿；要警醒内存如分饼，不可使弟兄争竞。"众门徒便俯伏在习题的磐石上，凿出真理的泉源。
>LFY以铁杖击碎死锁的荆棘网，用油膏抹文件系统的裂痕。有学生问："shell之道何其深？"LFY便展开命令行的约柜，显出重定向的红海分开。当复习至虚拟内存的奥秘，满室忽然寂静，仿佛西奈山被云雾遮盖。
>末了，他们两人在幻灯片上写下圣约，说："这便如芥菜种，你们当怀揣它在心田。"众人就收拾书包，各按着知识的支派归去。看哪，他们的灯常明，如同穹苍之上的星宿排列成调度算法。

## 第四章 存储器管理

*本章涉及概念和计算*

### **4.3 连续分配储存管理方式（126）**

连续管理储存方式（包括分配算法），分页管理（包括缺页中断），分段管理

- **4.3.2 固定分区分配和4.3.3 动态分区分配（126）的区别：** 
	1. ==**后面有两道选择题：固定分区分配的分区大小个数是不变的（固定好但允许不同），动态分配的分区（可变分区）大小和个数是会动态变化的；**==
	2. 反映在表上就是，两者都有空闲分区表，固定分配的表项不变，动态分配在回收/分配内存时会出现表项的增加和减少；
- 分区分配算法/搜索算法：了解一下就好
	- 首次适应FF：*第一个满足分配的内存块*
	- 最佳适应BF：*分完后剩余最少内存的内存块*
	- 最坏适应WF：*分完后剩余最多内存的内存块*
	- 循环首次适应NF：*从上次找到的地方继续，找第一个满足分配的内存块*
	- 例题：4~5章作业第三题
- **4.3.6 动态重定位（133）：**
	- **静态和动态重定位的区别：** 重定位技术是为了把逻辑地址转化为物理地址，静态重定位是在程序装入时一次（后续不改变）完成的，而动态重定位是在程序运行时才进行的的

### **4.4 对换（135）**

- 了解对换的概念及用途
	- 概念：对换也称为交换技术，把处于内存当中的一部分用户作业/进程换到磁盘上去，并不是用常规的磁盘存储操作，而是在磁盘中开辟一部分空间，这部分空间是用连接的方式来存放的，因为内存中放不下了/优先级比较低，于是暂时换出到磁盘中，这个空间称为对换空间，这种技术称为对换技术
	- ==选择题==：**对换和虚拟存储技术**（分页、分段管理）是**实现了内存扩充的两种方法**
	- ==对换是以进程为单位==

### **4.5 分页储存管理方式（138）**

- **4.5.1 页表大小：**
	- 分页时页面有固定的大小，它和系统相关，即系统指定大小为多少
- 每个页面的地址结构：![[神谕（又一次）-20250226162859553.png|400]]
	- **计算地址：给定逻辑地址，根据页面大小算出缺页和偏移量，再用页表的映射关系算出物理地址**
	- 例题：已知某分页系统,主存容量为64K字节,页面大小为1K,对一个4页大的作业, 其0、1、2、3页分别被分配到主存的2、4、6、7块中,试:(1)将十进制的逻 辑地址1023, 2500, 3500、4500 转换成物理地址;(2)以十进制的逻辑地址1023 为例画出地址变换过程图。
		- （1）1023 ÷ 1024 = 0 页，页内偏移 1023 % 1024 = 1023，页面0 映射到块 2，物理地址 = 2 × 1024 + 1023 = 3071。 2500 ÷ 1024 = 2 页，页内偏移 2500 % 1024 = 452，页面2 映射到块6，物理 地址 = 6 × 1024 + 452 = 6596。 3500 ÷ 1024 = 3 页，页内偏移 2500 % 1024 = 428，页面3 映射到块7，物理 地址 = 7 × 1024 + 428 = 7596。 逻辑地址 4500 ÷ 1024 = 4 页，页面4 不在内存中，这是一个缺页情况
		- （2）![[神谕（又一次）-20250301110010284.png|500]]
	- 页式存储管理允许用户的编程空间为32个页面(每页1KB),主存为16KB。如 有一用户程序为10页长，且某时刻该用户程序页表为0-8、1-7、2-4、3-10（逻辑-物理）。若分别遇到三个逻 辑地址0AC5H, 1AC5H, 3AC5H 处的操作,计算并说明存储管理系统将如何处理。
		- 0AC5十进制为2757，1AC5十进制为6853，3AC5十进制为15045， （1） 页号 = 2757 ÷ 1024 = 2，页内偏移 = 2757 % 1024 = 709，页号2映射到 物理块号4，物理地址为4 × 1024 + 709 = 4805 = 12C5H （2） 页号 = 6853 ÷ 1024 = 6，页内偏移 = 6853 % 1024 = 845，逻辑页号 6 不在页表中，因此会发生缺页错误。操作系统需要处理缺页中断，将该页加载到主存。 （3） 页号 = 15045 ÷ 1024 = 14，页内偏移 = 15045 % 1024 = 845，逻辑页号 14 不在页表中，因此会发生缺页错误。操作系统需要处理缺页中断，将 该页加载到主存。
- **4.5.2-2 快表的地址变换结构（141第二段）**：
	- **快表的缩写是：TLB**
	- 什么是快表：由于页表是存放在内存中的，这使CPU在每存取一个数据时，都要两次访问内存。第一次是访问内存中的页表，第二次访问实际的数据。为了提高访问的效率设置了快表。通过快表查询，可以直接得到逻辑页所对应的物理块号。
	- ==**快表是位于CPU存储器中的，不是存放在内存当中的！！！**==
- **4.5.4 两极和多级页表（142）**：
	- **为什么要设置两极和多级页表/目的**：是因为如果一个进程所需要访问的连续的内存空间太大，这时放在一个页表当中就会使得页表本身过大，去读取时可能也会产生多级中断，所以==**使用多级页表来减少页表容量**==，提升访问速度
- **4.5.5 反置页表（144）**：
	- 是为内存当中的每一个实页建立一个页表，==帮助我们实现虚页和实页的对照==
	- 为物理内存建立一张页表，是哪一个进程的哪一个虚页使用了这个页面，所以它也是==进行虚地址到实地址的转换的==
	- 反置页表是页表的一种实现方式，但不是为用户进程建立，而是为物理内存建立，所以它也是==**从逻辑地址到物理地址的转换，不能反过来找！！！**==

### **4.6 分段储存管理方式（145）**

- **分段和分页管理方式的主要区别是什么（148）：**
	- 页式储存管理是为了让虚页可以离散的去存放，==（物理）空间是不连续的==；段式是按逻辑分段进行存储，不是完全连续的，不同的段可以存放在不同位置，==一个作业的各个段不连续；**所以都是不连续的！**；==如果要完全的连续，就回到了分区算法
	1. 页是信息的物理单位
	2. 页的大小固定且由系统决定
	3. 分页的用户程序地址空间是一维的
	4. 4.6.3 信息共享：分段系统的一个突出优点是易于实现段（程序和数据）的共享，且对段的保护也十分简单易行（这句话也就说明了分页的缺点，段的共享只要加几个标志位，而页的共享需要将一页上的代码和数据分开，实现困难；分段后可以单独标识代码段和数据段，决定其访问权限，分页实现这一功能会十分复杂，需要在页表中加很多项）
- ==**分段地址的含意：**== 前面是段号，后面是段内地址，**一个逻辑分段允许的最大长度是由段内地址决定的（2^n）**
	- ![[神谕（又一次）-20250227153945825.png|400]]

## 第五章 虚拟存储器

- 虚拟存储器的基本概念：
	- 虚拟存储器并不是实际存在的，而是在程序运行时给它构建的一个空间是虚拟空间（多出来）**==不是物理空间（运行）和逻辑空间（程序），所以它没有实际对应的物理空间，不是辅存，也不是内存==**
	- 判断题第四题：程序员在编写程序时不需要关注虚存的大小，我们也不将虚存和实际内存对应，但==**程序的运行速度/吞吐量受到实际内存大小的限制**==

### **5.2 请求分页存储管理方式（156）：**

- **为什么叫“请求分页”：**
	- 书中提到了请求分页、预调页
	- 省流：==**是由缺页中断来触发页面调用/请求的**==
	- 程序一开始不会把完整的程序调入，是由缺页中断来让我们把实际需要的虚页面调入内存，完整的程序/要访问的虚页在缺页中断时调来，所以称为请求分页
- **5.2.1-1 请求页表机制（157）：** 
	- **页表的各个字段的含意：**![[神谕（又一次）-20250227161112484.png]]
		- **页号：一个进程的虚页**
		- **物理块号：这个虚页放在哪个实际的物理内存当中**
		- **状态位P：也成为存在位，用于指示该页是否已调入内存，供程序访问时参考**
		- **访问字段A：用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问，提供给置换算法（程序）在选择换出页面时参考**
		- **修改位M：标识该页在调入内存后是否被修改过**
		- **外存地址：用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考**
- 缺页中断的处理过程：
	- **缺页中断的目的：** 缺页中断是指要**访问的虚页不在内存中，需要从辅存中调入** ，==不是用来扩充内存容量==，并不一定是指内存空间不够（内存空间不够是换入换出/替换，缺页中断时内存有可能有足够的空间容纳虚页）
	- 发生缺页中断的时候，会把引起中断的指令压入到栈当中
	- ==**缺页中断不可屏蔽！！！**==
	- **==单项选择第一题==/缺页中断和普通中断的区别：** 普通中断是在一条指令结束后才会产生中断，而缺页中断会在指令执行的当中产生中断，因此在缺页中断后引发中断的指令是需要重新执行的，所以==**缺页中断时当前指令（根据其地址）会被压入到一个寄存器中进行保存**==，而普通中断只需要保存PC的值/压下一条指令
	- 索引：可以把缺页中断理解为，需要读取数据的虚页地址不在内存，可以理解为在页表中的它的访问位/存在位是无效的，==**地址映射失败了**==，也就要进行数据调入
	- 页面分配块数/页面大小的讨论
	- **缺页率受以下几个因素的影响（162）：** 
		1. 页面大小：页面划分较大，则缺页率较低，反之较高
		2. 进程所分配物理块的数目：所分配的物理块数目越多，缺页率越低，反之越高
		3. 页面置换算法：算法的优劣决定了进程执行过程中缺页中断的次数，因此缺页率是衡量页面置换算法的重要指标
		4. 程序固有特性：程序本身的编制算法对缺页中断次数有影响，根据程序执行的局部性原理，程序编制的局部化程度越高，相应执行的缺页程度越低
		- ==**注意：以上因素和缺页率并不是直接数值关系/没有逻辑的因果关系，并不是页面大小增加一倍缺页率就变为二分之一**==
- ==**5.1.2-2 虚拟存储器的特征：**== 
	- ==**虚拟存储器不会导致性能下降**==
	1. 多次性
	2. 对换性
	3. 虚拟性

### **5.3 页面置换算法**

- 用处：==选择一个**内存的页框**将其淘汰==
- 掌握处理步骤：
	- 不命中就会触发缺页中断
	1. 最佳置换：*选择未来最久不再使用的页面进行淘汰*
	2. 先进先出FIFO：*淘汰最早加载的页面*
	3. 最近最久未使用LRU：*淘汰最久未使用的页面*
	- 例题：一进程已分配到4个页帧,见下表(编号为十进制,从0开始)。当进程访问第 4 页时,产生缺页中断,请分别用FIFO、LRU算法，决定缺页中断服务程序选择换出的页面。![[神谕（又一次）-20250301111538284.png]]
		- FIFO算法：由于页面3进入内存的时间最早，所以将页面3换出内存
		- LRU 算法：最近访问时间最早的是页面1（160），表示页面1最近使用最少，所以将页面1换出内存
	- 在一个请求分页存储管理系统中,一个作业的页面走向为 4,3,2,1,4,3,5,4,3,2,1,5,当分配给作业的物理块数分别为3和4时,试计算采 用下述页面淘汰算法时的缺页率(假设,开始执行时主存中没有页面),并比较结果。1)最佳置换算法。2)先进先出置换算法。3)最近最久未使用算法。
		- ![[神谕（又一次）-20250301112433652.png]]
		- ![[神谕（又一次）-20250301112445397.png]]
		- ![[神谕（又一次）-20250301112456197.png]]

### **5.4 “抖动”与工作集**

- **5.4.1-2 产生抖动的原因（170）：** 系统运行的**1进程太多，2存储资源不足**，因此分配给每一个进程的物理块太少
- **5.4.3-3 利用“L=S”原则调节缺页率（172）：==Denning对抖动进行了研究==**，也是==**Denning提出了程序访问局部性原理**==，是他建立了请求分页系统
	- ==如果内存不足，操作系统频繁的交换，会导致程序性能降低，这就是Denning研究的抖动==

## 第六章 输入输出系统

- lfy：设备管理有一道大题

### **6.1**

- 6.1.2 I/O系统的层次结构和模型/设备管理系统：
	- 五层结构：![[神谕（又一次）-20250228134716502.png]]

### **6.2 IO和设备控制器**

- **6.2.4 IO通道（187）：** 
	- 6.2.4-1 IO通道设备的引入：IO通道是一种特殊（执行特定指令的专用）的处理机，只执行通道指令，能执行的指令种类数很少
	- 设备控制器的能力不够，只能对应特定的设备，而在大型设备中需要分离数据的输入输出，所以引入了通道

### **6.4 **

- **6.4.3-3 DMA/直接存储器访问（196）：** TODO
	- DMA控制器是做什么的：把数据从设备上读入，再直接放到存储器/设备里，跳过CPU
	- 它的使用方式：
		- ![[神谕（又一次）-20250228203605175.png|400]]
	- 理解性的方式
	- 步骤（判断题第20题）
		1. 启动设备
		2. 开始读写
		3. DMA控制器启动，传输数据，结束后申请中断
		- ==**所以DMA必须使用中断，说不需要中断就错，说需要中断合作就对**==

### **6.6 **

- **6.6.2 假脱机（Spooling）系统（205）：**
	- 理解这个系统是干什么的，干什么就是它的目的
	- ==目的：可将一台物理I/O设备虚拟为多台逻辑I/O设备，这样也就允许多个用户共享一台物理I/O设备，**即把独占设备变成共享设备**==

### **6.8 磁盘**

- 磁盘控制器是属于设备控制器，不能直接往上写程序，是硬件，因此一些软件的概念和它没有关系，比如缓冲（缓存是有的）（？存疑）
- ==**磁盘的高速缓存就是页面置换，不是缓存，不是磁盘控制器的功能**==（判断题第19题）（？存疑）
- *区别硬/软件的方法是根据你是直接往上写程序还是需要借助别的设备写入*
- **调度算法（218）的处理过程：** 
	- 需要访问的磁道请求：18, 38, 39, 55, 58, 90, 150, 160, 184
	1. SSTF最短寻道优先：*找最近的*
		- ![[神谕（又一次）-20250228204502964.heic|400]]
	2. SCAN扫描算法：*当前方向下最近的，然后再反向走到底*
		- ![[神谕（又一次）-20250228204142973.heic|400]]
		- 例题：假设磁头当前位于第105道,正在向磁道序号增加的方向移动。现有一个磁道访问请求序 列为35,45, 12, 68, 110, 180, 170, 195,采用 SCAN 调度(电梯调度).算法得到的磁道访问序列和 平均寻道长度是多少？
			- 磁道访问序列为：110 ->170->180->195->68->45->35->12 总共移动了195-105+195-12=273 个磁道 平均寻道长度为273 / 8 = 34.125

## 第七章 文件管理

### **7.1 文件和文件系统**

- 文件系统是什么（237~240？）：
	- 包括文件和管理文件的一组程序、软件和数据结构，他们一起构成了文件系统
	- 文件的管理实际是对我们用来存放文件的辅助存储空间的管理
- 绝对路径是从根目录开始访问的

### **7.2 文件的逻辑结构**

- 这一章讲的是文件的逻辑结构，它**不会决定文件的存储方式**（即连续还是随机的读），是由第八章的物理结构决定的

### **7.3 文件目录**

- **7.3.1-2 索引节点：** 
	- 文件控制块/索引节点是用于管理文件的数据结构
	- （类）UNIX当中，索引节点分为文件本身在磁盘上的索引节点以及读入内存时它在内存上相应创建的内存的索引节点，**这两种索引节点的内容是不一样的**（234）：
		- 磁盘索引节点是外存索引节点
		- 在读入内存时创建了内存索引节点
- **7.3.2 文件目录：** 
	- **作用：帮我们按文件名访问（即实现文件的存取）**
- 微内核当中是没有文件系统的（不必须）
- **7.3.4 目录查询技术（239）：** 
	1. 线性检索法：
		- ![[神谕（又一次）-20250228205013008.png|700]]
	2. Hash方法（？存疑）：
		- 如果我们建立了一张Hash索引文件目录，便可利用Hash方法进行查询，即系统利用用户提供的文件名，并将它变换为文件目录的索引值，再利用该索引值到目录中去查找

### **7.4 文件共享**

- 硬/软链接实现共享的方式不同：
	- 软链接也称之为符号链接
	- 软链接本身是一个目录文件，记录了一个目录，然后再指向共享的文件，所以通过硬链接可以找到共享的文件，符号链接本身并不是我们直接要访问的文件
	- 硬链接是通过访问相同的文件，符号链接是通过访问相同的路径
- UNIX中文件共享是什么（判断题14题）：
	- 逻辑索引节点；物理索引节点；内存索引节点；外存索引节点；
	- 内存索引节点和外存索引节点：内存打开的索引结构，是内存的数据结构
	- 逻辑索引节点和物理索引节点：逻辑索引节点是为了支持不同的文件系统，逻辑索引节点底下对应一个物理索引节点，不同的文件系统的索引节点是不一样的，这是为了实现多文件系统的支持
		- ==**虚拟索引节点和物理索引节点的支持，如FAT没有外存索引节点（UNIX系统才有外存索引节点），内存索引节点是有的**==

### **7.5 文件保护**

- **chmod数字含意：** 
	- ==10进制写的：754，理解为0754（8进制），7是用户组，5是同组用户，4是组外用户，写成2进制==
		- r读=4，w写=2，x运行=1
		- 即用户组可读写运行；同组用户可读可运行不可写；组外用户可读不可写和运行；

## 第八章 磁盘储存器的管理

### **8.1 外存的组织方式**

- **8.1.5-3 混合索引（258）计算：** 
	- **给你一个地址，计算它需要几次访问，即它处于第几级索引**
		- 某文件系统采用索引结点存放文件的属性和地址信息,簇大小为4KB。每个文件索引结点占64B,有 11 个地址项,其中直接地址项8个,一级、二级和三级间接地址项各1个，每个地址项长度为4B,请回答下列问题:
			1. 该文件系统能支持的最大文件长度是多少? (给出计算表达式即可)
			2. 文件系统用1M个簇存放文件索引结点,用512M个簇存放文件数据。若一个图像 文件的大小为5600B,则该文件系统最多能存放多少个这样的图像文件?
			3. 若文件F1 的大小为6KB,文件F2的大小为40KB,则该文系统获取F1和F2最后一个簇的簇号需要的时间是否相同?为什么?
			- 每个簇为4KB，每个地址项长度为4B，所以每个簇可以存放4KB / 4B = 1024个地址项，直接地址项 = 8 * 4KB = 32KB；一级间接地址项 = 1 * 1024 * 4KB = 4MB; 二级间接地址项 = 1 * 1024 * 1024 * 4KB = 4GB; 三级间接地址项 = 1 * 1024* 1024 * 1024 * 4KB = 4TB。所以能支持的最大文件长度为32KB+4MB+4GB+4TB
			- 每个文件需要5600B / 4KB = 2 个簇，文件索引结点共有1M * 4KB / 64B = 64M个；512M个簇存放文件数据，能存放256M个文件，但由于受限于索引结点个数，所以 该系统最多能存放64M个这样的图像文件
			- F1需要6 / 4 = 2个簇 < 8，直接地址项就能直接访问，因此获取最后一个簇的簇号 只需要通过直接地址项即可；而F2需要40 / 4 = 10个簇 > 8， 所以需要用一级间接地址项，因此获取最后一个簇的簇号需要通过一级间接地址项指向。
- **三种物理组织方式的对比：**
	1. 连续组织方式：
		- 也称为连续分配方式，为每个文件分配连续的地址空间，在文件控制块中提供起始块号和长度
		- 优点：（1）顺序访问容易（2）顺序访问速度快（3）可以随机访问
		- **了解访问过程（书上例子），要求计算访问次数/插入删除的计算**
			- 例题：在某个文件系统中,每个盘块为512个字节,文件控制块占64个字节,其中文件名占8个字 节。如果索引结点编号占2个字节,对一个存放在磁盘上的、256个目录项的目录,试比较引入索引结点前后,为找到其中一个文件的FCB,平均启动磁盘的次数
				- 引入索引结点之前： 256 * 64B / 512B = 32，（ 1+32）/ 2 = 16.5 次。 引入索引结点之后： 256*（8+2）/ 512B = 5，（ 1+5）/ 2 + 1 = 4 次。
	2. 链接组织方式（两种）：
		- 隐式链接
			- 没有一个集中的数据结构记录会去访问哪些数据块，显示链接有
		- 显式链接
			- 缺点：相对于连续组织方式，不能随机访问（？存疑）
			- 优点：有利于文件的扩展，而连续组织方式不利于文件的动态增长
	3. 索引组织
	- **文件系统为每个文件建立一张指示逻辑/物理记录的表，这一点只对显式链接成立，对隐式链接不成立**
	- **链接文件和索引文件都比较容易进行动态增长，但是连续文件很难实现**

## 实验相关

- LINUX中常见的文件类型有哪些：

| **文件类型**   | **标识符** | **说明**                | **示例**                    |
|------------|---------|-----------------------|---------------------------|
| 普通文件       | \-      | 普通的文本文件、二进制文件、可执行文件等  | touch myfile\.txt         |
| 目录         | d       | 用于存储文件和子目录的文件夹        | mkdir mydir               |
| 符号链接       | l       | 指向另一个文件或目录的快捷方式       | ln \-s myfile\.txt mylink |
| 块设备文件      | b       | 硬盘、U 盘等存储设备的接口文件      | /dev/sda                  |
| 字符设备文件     | c       | 处理字符流的设备，如键盘、串口等      | /dev/tty                  |
| 管道文件（FIFO） | p       | 进程间通信的先进先出通道          | mkfifo mypipe             |
| 套接字文件      | s       | 进程间通信的网络或本地 socket 连接 | /tmp/mysocket             |

- LINUX中常见的文件系统调用有哪些
	- ==**pipe系统功能调用**==
		- `pipe` 创建一个 **单向数据通道**，一个进程写入数据，另一个进程读取数据。从pipe\[1]写入，从pipe\[0]读出
```C++
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main() {
    int pipefd[2];  // 用于存储管道的文件描述符
    pid_t pid;
    char buffer[100];

    // 创建管道
    if (pipe(pipefd) == -1) {
        perror("pipe failed");
        exit(EXIT_FAILURE);
    }

    // 创建子进程
    pid = fork();

    if (pid < 0) {
        perror("fork failed");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {  
        // 子进程
        close(pipefd[1]); // 关闭写端
        read(pipefd[0], buffer, sizeof(buffer));
        printf("子进程收到数据: %s\n", buffer);
        close(pipefd[0]); // 关闭读端
    } else {  
        // 父进程
        close(pipefd[0]); // 关闭读端
        char message[] = "Hello from parent!";
        write(pipefd[1], message, strlen(message) + 1);
        close(pipefd[1]); // 关闭写端
    }

    return 0;
}

```


- LINUX中如何实现文件系统的挂载和卸载命令
	- LINUX系统没有逻辑分区。盘符，如果要实现多系统支持时，使用哪些命令
	- ==**mount 和 unmount**==
		- mount \[-t 文件系统类型] 设备路径 挂载点 \[选项]
			- 假设 `sdb1` 是 U 盘的设备文件：`mount /dev/sdb1 /mnt/usb`
			- `mount` 或 `df -h` 可以查看当前挂载的设备
		- umount \[挂载点 | 设备路径]
			- `umount /dev/sdb1`


