
# 第一章

## 1.1 软件危机

### **如何维护数量不断膨胀的软件/软件危机（2）：**

- 如何开发：以满足对软件日益增长的的需求
- 如何维护（数量不断膨胀的已有软件）

### **软件危机的典型表现（选择判断题）（2）：**

- 对软件开发成本和进度的估算很不准确
- 用户对“已完成的”软件系统不满意的现象经常发生
- 软件产品的质量都靠不住
- 软件常常是不可维护的
- 没有适当的的文档资料
- 软件成本在计算机系统中成本所占的比例逐年的上升
	- 我们说硬件是满足摩尔定律的，但是软件还要人工来开发，所以它的效率不像摩尔效率一样极速提升，所以它的成本在这个总成本中所占的比例是逐年上升的。
- 软件开发效率的提升远远跟不上计算机应用普及和深入的趋势

### **产生软件危机的原因（3）：**

- *全部读一遍、理解*
- 软件不同于硬件，它是计算机结构的逻辑部件而不是物理部件，因此，管理和控制软件开发过程相当困难
- 软件不同于一般程序，显著特点是规模庞大，**复杂度将随着规模的增长呈指数上升**

### **概要设计、详细设计到编程（理解）（4上开始）：**

- 测试工作通常占整个工作量的40%到50%，编写程序代码占整个工作量的10%到20%，维护占软件总费用的55%到70%
- ![[谢谢你，波波-20250307154443886.heic|500]]
- 理解上图中早中后三个时期的原因：
	- 早期引入变动，涉及的面较少，因而代价也比较低
	- 中期软件配置的较多成分已经完成，引入一个变动对所以已完成的配置成分都要做相应的修改，不仅工作量大，而且在逻辑上也更复杂，因此付出的代价剧增
	- 在后期“已经完成”时引入一个变动，当然需要更高的代价
- ==**软件的三要素：**==一个软件产品必须由一个完整的配置组成，主要包括**程序、文档和数据**等成分//（4最下）软件是**程序、数据和相关文档**的完整集合

### **==软件的三要素：==程序、文档和数据的定义（5）：**

- 程序：完成预定功能和性能的可执行的指令序列
- 数据：程序能够适当的处理信息的数据结构
- 文档：开发、使用维护体系所需要的这个图文资料

### **为了解决软件危机，既要有技术措施（方法和工具），还要有必要的组织管理措施。软件工程正是从管理和技术两个方面研究如何更好的开发维护计算机软件的一门新兴学科。（5）**

- 一般讲到软件工程就肯定会提到**开发维护**。

## 1.2 软件工程

### **软件工程的定义（理解）（5）：**

- 概括的说，软件工程是指导计算机软件开发和维护的一门工程学科。
- *采用工程化的思想来开发和维护软件，就叫软件工程。*
- 理解下面的两个定义：TODO

### **软件工程的本质特征（理解）（6）：**

1. 软件工程关注大型程序的构造
2. 软件工程的中心课题是控制复杂性
3. 软件经常变化
4. 开发软件的效率非常重要
5. 和谐的开发是开发软件的关键
6. 软件必须有效地支持它的用户
7. 软件工程中通常由具有一种文化背景的人替具有另一种文化背景的人来创造产品

### **软件工程的基本原理（理解）（7）：**

1. 用分阶段的生命周期计划严格管理
2. 坚持进行阶段评审
3. 实行严格的产品控制
4. 采用现代程序设计技术
5. 结果能够清楚的审查
6. 开发小组人员少而精
7. 承认不断改进软件工程实践的必要性

### **软件工程方法学（9）：**

- **三要素：方法、工具和过程**
- 传统方法学（理解）：第九章
- 面向对象方法学（理解）：

### ==**软件生命周期（11）：**==

- 软件生命周期由**软件定义、软件开发和运行维护**组成
	- **软件定义：问题定义、可行性研究和需求分析**
		- 了解每一个时期各自做什么事情==**（关键问题）**==：
		- 问题定义：**“要解决的问题是什么？”**
		- 可行性研究：**“对于上一个阶段所确定的问题有行得通的解决方法吗？”**
		- 需求分析：**“为了解决这个问题，目标系统必须做什么？”**
			- 有==规格说明书==
	- **软件开发：总体设计（概要设计）、详细设计（模块设计）、编码和单元测试、综合测试。前两个称为系统设计，后两个称为系统实现。**
		- 总体设计：**“该怎样实现目标系统？”**
			- 设计三种方案：低中高成本，在三种方案中权衡利弊，设计一种最佳方案
			- 设计程序的体系结构，也就是确定程序有哪些模块组成以及模块间的关系
		- 详细设计：**“应该怎样具体地实现这个系统 ？”**
			- 属于设计阶段，==不是敲代码==
			- 确定==算法和数据结构==
	- **运行维护（主要任务是软件持久地满足用户需要）（14）：包括改正性维护、适应性维护、完善性维护和预防性维护**

## 1.4 软件过程

### ==**软件过程模型（14开始）：**==

- *理解每个模型*
- 为什么叫软件过程模型：通常使用生命周期模型简洁地描述软件过程。生命周期模型规定了把生命周期划分成哪些阶段以及各个阶段的执行顺序，因此称之为过程模型。**（生命周期模型也称为过程模型）**
- 瀑布模型：是传统的唯一广泛常用的数据设计模型。传统的这个软件过程模型都可以从服务模型来描述。
	- 特点：
		1. 阶段间有顺序性和依赖性：*一个做完了做另一个* 
		2. 推迟实现的观点：*前面做完才能够编码和测试*
		3. 质量保证的观点：每个阶段都要完成规定的文档（瀑布模型是由文档驱动的）
	- 适用情况：*用户的需求很明确的时候。* 
	- 当**用户的需求不明确**时，在开发初期很难得到一个完整的准确的需求规约，或者得到的软件需求规约不完整、不准确，有时甚至可能有歧义。**所以我们就采用了一种方法，叫快速原型的方法。**
	- 瀑布模型和快速原型的差别：
		- 需求明确时，可以根据需求总结出规格说明书
		- 需求不明确时，只能用快速原型法导出用户的需求，最后再得到规格说明书
		- *后面的都一样*
- 增量模型：分批逐步向用户提交产品，整个软件分解成许多增量构建
	- 优点：
		1. 能够在较短时间内向用户提交可完成部分工作的产品
		2. 逐步增加产品功能，可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新软件可能带给用户组织带来的冲击
- 螺旋模型：
	- 特点：考虑==**软件风险**==：项目越大越复杂，承担这个项目的风险也越大，螺旋模型的基本思想就是用原型或其他方法来尽量的降低风险
	- 优点：
		- 对可选方案和约束条件的强调有利于已有软件的重用
		- 有助于把软件质量作为软件开发的一个重要目标
		- 减少过多的测试或者测试不足带来的风险
		- 螺旋模型中维护只是软件的另一个周期
- 喷泉模型：
	- 在面向对象中使用
- RUP（Rational统一过程）：
	- **四个阶段的工作目标（24）：**
		- 初始阶段：建立业务模型
		- 优化阶段：确定体系结构
		- 构建阶段：开发所有构件和应用程序
		- 移交阶段：把开发出产品交给用户使用

### **极限编程（26）：**

- *读一遍就行*

# 第二章：26：54

## 2.1 可行性研究的任务

### **可行性研究的四个方面（35）：**

- 技术可行性
- 经济可行性
- 操作可行性
- 法律、社会效应

## 2.2 可行性研究过程8点（理解）

- 复查系统规模和目标
- 研究目前正在使用的系统
- 导出新系统的高层逻辑模型
- 进一步定义问题
- 导出和评估供选择的解法
- 推荐行动方针
- 草拟开发计划
- 书写文档提交审查
- ==***系统流程图***==：不要和程序流程图搞混了
	- 是在描述==**物理系统**==
- ==***数据流图***==：大题

## 2.2 数据字典

- 数据字典的定义（47）：数据字典是关于数据的信息的集合，是对数据流图包含的所有元素的定义的集合
- 数据流图和数据字典共同构成系统的逻辑模型
- 数据字典的内容（简单了解？）：数据流、数据流分量、数据存储、处理
- **定义数据的方法**（47下）：前三个为基本类型，注意写法
	- 数据
	- 选择
	- 重复
	- 可选

# 第三章：

## 3.1 需求分析的任务（了解）

- 功能需求
- 性能需求
- 可靠性和可用性需求
- 出错处理需求
- 接口需求
- 约束
- 逆向需求
- 将来可能提出的需求

## 3.6 ==*状态图*==

- 状态图的定义（66）：
	- 事件表达式（**迁移的定义**）：事件说明 **【守卫条件】+动作表达式** ， *直接写事件名也可以*

# 第五章：

## 5.1 设计阶段（91）

- 两个主要阶段：
	- **系统设计**阶段：**确定**系统的**具体实现方案**
	- **结构设计**阶段：**确定软件结构**
- 9个步骤（了解）：
	- **设想供选择的方案**
	- 选取合理的方案
	- **推荐最佳方案**
	- 功能分解
	- 设计软件结构
	- 设计**数据库**
	- 制定测试方案：**是在整体设计的时候就有测试计划的，不是等到最后再产生的**
	- 书写文档
	- 审查和复审

## 5.2 设计阶段（前四点了解）（94）

- 模块化
- 抽象
- 逐步求精
- 信息隐藏和局部化
- **模块独立**：
	- 模块独立程度由两个定性标准来度量，第一个叫内聚，第二个叫耦合
		- **内聚：衡量一个模块内部各个元素彼此结合的紧密程度**
			- *越高越好*
			- **最好的是功能内聚，最差的是偶然内聚**
		- **耦合：衡量不同模块彼此间相互依赖的紧密程度**
			- 分为数据耦合、控制耦合、特征耦合、公共环境耦合、==**内容耦合（包括以下四种情况）**==
				1. 一个模块访问另一个模块的内部数据
				2. 一个模块不通过正常入口而转到另一个模块的内部
				3. 两个模块有一部分代码重叠
				4. 一个模块有多个入口
				- 坚决避免使用内容耦合
			- 耦合是影响软件复杂程度的一个重要因素，应该采取下列设计原则：
				- 尽量使用数据耦合
				- 少使用控制耦合和特征耦合
				- 限制公共环境耦合的范围
				- 完全不用内容耦合
	- 设计的时候力争做到高内聚，低耦合，从而有较高的模块独立性

## 5.3 启发规则7条（理解）（99）

- 改进软件结构提高模块独立性
- 模块规则应该适中
- 深度、宽度、**扇出和扇入**都应适当：TODO
- ==**模块的作用域应该在控制域之内**==：不要反过来
- 力争降低模块接口的复杂程度
- 设计单入口单出口的模块
- 模块功能应该可以预测

## 5.5 面向数据流的设计方法（105）

- 变换流：*在变换中心进行加工处理*
- 事物流：*进入事务中心，从若干个选择中选一个执行*
- *边界？*![[谢谢你，波波-20250308164050217.heic|800]]

# 第六章：

## 6.1 结构程序设计（118）

- **三种基本的控制结构：顺序、选择和循环**+Do_Until和多分支
- 什么是结构化程序设计/定义 **（五个要素）**：仅仅通过顺序、选择和循环，且是单入口和单出口

## 6.3 程序设计的工具（125）

- 程序流程图的缺点：
	- 程序流程图本质上不是逐步求精的好工具
	- 程序流程图用箭头表示控制流，因此程序员不受任何约束，可以不顾程序结构设计的流程，随意转移控制
	- 程序流程图不易表示数据结构
	- **怎么把程序流程图转为盒图**
- ==***盒图（N-S图）***==的特点：
	- 功能域明确
	- 不可能随意转移控制
	- 很容易确定局部和全程数据的作用域
	- 很容易表示嵌套关系
- ==***PAD图（问题分析图）***==的优点（了解，波波甚至不愿意念一遍）：
	- 设计出的是程序化结构
	- 程序结构清晰
	- 表现逻辑易读/懂/记
	- 容易转换成高级语言源程序
	- 可用于表示程序逻辑和数据结构
	- 支持从顶到下、逐步求精
- **程序流程图转为盒图，再转为PAD图**
- 判定表：
	- 四个区分别表示什么
	- ![[谢谢你，波波-20250308165933746.heic|800]]
	- ![[谢谢你，波波-20250308165909701.heic|800]]
- 判定树：![[谢谢你，波波-20250308170026550.heic|800]]

## 6.5.1 市场环境复杂度的方法McCabe/Halstead（137）

- TODO

# 第七章：

## 7.2 软件测试基础（150）

- 软件测试的目标：
	- 测试是为了发现程序中的错误而执行程序的过程
	- 好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案
	- 成功的测试是发现了至今为止尚未发现的错误的测试
- 所以以下是**错误的**： 测试是为了表名程序是正确的 X
- **测试不能证明程序是正确的**
- 软件测试准则（了解）：
	- 所有的测试都能追溯到用户需求
	- 应该在测试开始之前就制定好测试计划
	- 应用Pareto准则（二八原则）
	- 从“小规模”到“大规模”
	- 穷举测试是不可能的
	- 应该让独立的第三方做
- 白盒和黑盒的定义（151）：
	- 白盒测试（结构测试）：*完全知道程序的结构和处理算法，按程序的逻辑测试*
	- 黑盒测试（功能测试）：*不知道程序的结构和处理算法，只检查程序功能能否按规格说明书运行*
- 测试步骤（151）：模块测试、（子）系统测试、验收测试、平行运行

## 7.4 集成测试（157）

- 模块组装成程序时有两种方法：
	- 非渐增式测试方法：
	- 渐增式测试：有**自顶向下和自底向上**两种集成策略
		- *读一遍从7.4.2~7.4.4，了解*~~（不是哥们）~~

## 7.5 确认测试

- Alpha测试和Beta测试的区别（161）
	- Alpha测试：用户在开发者的场所测试
	- Beta测试：用户软件的新用户在一个或多个客户场测试

## 7.6 白盒测试技术

- 逻辑判断准则5个（162）：
	- 语句覆盖
	- 判定覆盖
	- 条件覆盖
	- 判定/条件覆盖
	- 条件组合覆盖

## 7.7 黑盒测试技术

- 优化方法（172）==**看PPT例子**==
	- **等价划分**
	- **边界值分析**
	- 错误推测法

## 7.8 调试（176）

- 调试是什么：在测试发现错误之后，排除错误的过程
- 调试的途径3个（了解）（178）：
	- 蛮干法
	- 回溯法
	- 原因排除法

# 第八章：

## 8.1 软件维护的定义

- 4种维护（189）：
	- 改正性维护：改正诊断和改正错误的过程
	- 适应性维护：为了和变化了的环境适当的配合而进行修改软件的活动
	- 完善性维护 **（占比例最大）**：为了满足用户提出增加的新功能而修改软件
	- 预防性维护

## 8.4 软件可维护性的几个方面

- 要考虑的因素（了解）（195）：可理解性、可测试性、可修改性、可移植性

# 第9️⃣章：

## 9.1 

- 面向对象的方法学**（记住英文、四个要素）**：
	- **OO = objects + classes + inheritance + communication with messages**
	- OO：对象、类、继承、消息通信
- 面向对象方法的优点（了解）：
	- 与人类习惯的思维方法一致
	- 稳定性好
	- 可重用性好
	- 较易开发大型软件产品
	- 可维护性好

## 9.2 

- 消息的三个要素（212）：
	- 接受消息的对象
	- 消息选择符（消息名）
	- 零个或多个变元

## 9.3 

- 面向对象方法需要建立三种形式的模型（216）：
	- 描述软件系统数据结构的对象模型
	- 描述系统控制结构的动态模型
	- 描述系统功能的功能模型
- 在任何情况下，**对象模型始终都是最重要、最基本、最核心的**

## 9.4 对象模型

- 对象模型定义（216）：表示静态的、结构化的系统的数字性质，是模拟客观世界实体的对象以及对象之间彼此的关系的映射，描述了系统的现代结构
- 通常用UML提供的**类图来建立对象模型**
- ==**多重性？（219）：**==：两个点不是三个！
	- ![[谢谢你，波波-20250308174852399.heic|800]]
- ==***类图***==：聚集、组合、**泛化**、依赖
	- *关联关系是最重要的。就是不管是继承派生，不管是继承还是什么，他其实都是关联关系。关联关系是最范围的，关联关系是最泛的一个。他们之间到底是依赖的，是什么关系，你搞不清楚，给我画关联。如果你知道他一定有关系，就画一条线过去就可以了。*
	- *你要把这个位找出来，然后再看他们之间的这个继承关系跟他有没有什么关联关系有了就加不同性丢上去就可以了*

## 9.6 功能模型

- ==**UML图**==：*就是我们的泛化就是系统关系，肯定是有用力和用力之间有一个还有一个扩展，还有一个包含的迎客的扩展和这个继承就这三种。然后小人和小人之间就一个继承关系，小人和小人之间就继承关系就行了。对吧？对，所以说就是一个继承。汽车关系实现的和ecover就这三种就这三种就这三种，就这三种，你不要弄错了，就这三种。然后一个test和集成，一个tent和那个u code，就写那个英文版就行了。* TODO
- ==**顺序图和状态图**==：*如果顺序，我们顶部顶上一定画的是累啊累加上下划线类名就是加上下划线表示实际名对象是吧？你反正一定有下划线在上面就行了。如果上面错了，怎么错了，反正错一个扣一分，3减1分。*

# 第十一章

## 11.1 面向对向设计的准则

- （259下）优秀设计就是权衡各种因素，从而使得系统在整个生命周期中总开销最小的设计
- 对软件系统而言，60%以上的软件费用是用于软件维护，所以优秀设计的一个主要特点是容易维护。
- **面向对向设计的准则6个：** 和5.2的前三个一样
	- 模块化、抽象、信息隐藏
	- 弱耦合2类：
		- 不同？：对象不能完全独立，将两个对象必须相互联系，相互依赖，应该通过公共接口实现耦合
		- 
	- 强内聚、可重用
	- 